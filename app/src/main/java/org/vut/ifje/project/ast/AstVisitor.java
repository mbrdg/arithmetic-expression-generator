package org.vut.ifje.project.ast;

import org.vut.ifje.project.ast.expr.Expr;
import org.vut.ifje.project.ast.expr.binary.*;
import org.vut.ifje.project.ast.expr.literal.NumExpr;
import org.vut.ifje.project.scanner.Token;
import org.vut.ifje.project.scanner.TokenType;

/**
 * AST visitor is concrete implementation of a visitor intended to transverse the AST generated by a parser.
 *
 * @see org.vut.ifje.project.ast.Visitor
 */
public class AstVisitor implements Visitor<String> {
    @Override
    public String visitNumExpr(NumExpr expression) {
        Token token = expression.token();
        return token.type() == TokenType.POSITIVE_NUMBER ? token.lexeme() : '-' + token.lexeme();
    }

    @Override
    public String visitAddExpr(AddExpr expression) {
        return visitBinaryExpr(expression, " ");
    }

    @Override
    public String visitSubExpr(SubExpr expression) {
        return visitBinaryExpr(expression, " ");
    }

    @Override
    public String visitMulExpr(MulExpr expression) {
        return visitBinaryExpr(expression, " ");
    }

    @Override
    public String visitDivExpr(DivExpr expression) {
        return visitBinaryExpr(expression, " ");
    }

    @Override
    public String visitModExpr(ModExpr expression) {
        return visitBinaryExpr(expression, " ");
    }

    @Override
    public String visitPowExpr(PowExpr expression) {
        // NOTE: This is where right-associativity is handled for exponentiation
        if (expression.left().precedence().compareTo(expression.precedence()) <= 0) {
            return parenthesize(expression.left()) + expression.separator() + expression.right().accept(this);
        }

        return visitBinaryExpr(expression, "");
    }

    private String visitBinaryExpr(BinaryExpr expression, String separator) {
        return parenthesizeIfNeeded(expression, expression.left()) +
                separator + expression.separator() + separator +
                parenthesizeIfNeeded(expression, expression.right());
    }

    private boolean innerHasLowerPrecedence(Expr outer, Expr inner) {
        return inner.precedence().compareTo(outer.precedence()) < 0;
    }

    private String parenthesize(Expr expression) {
        return '(' + expression.accept(this) + ')';
    }

    private String parenthesizeIfNeeded(Expr outer, Expr inner) {
        return innerHasLowerPrecedence(outer, inner) ? parenthesize(inner) : inner.accept(this);
    }
}
