package org.vut.ifje.project.ast;

import org.vut.ifje.project.ast.expr.Expr;
import org.vut.ifje.project.ast.expr.binary.*;
import org.vut.ifje.project.ast.expr.literal.NumExpr;
import org.vut.ifje.project.scanner.Token;
import org.vut.ifje.project.scanner.TokenType;

/**
 * AST visitor is concrete implementation of a visitor intended to transverse the AST generated by a parser.
 *
 * @see org.vut.ifje.project.ast.Visitor
 */
public class AstVisitor implements Visitor<String> {

    // Helper enum to tell whether we are dealing with a lhs or rhs expression
    private enum Side {
        LEFT,
        RIGHT
    }

    @Override
    public String visitNumExpr(NumExpr expression) {
        Token token = expression.token();
        return token.type() == TokenType.POSITIVE_NUMBER ? token.lexeme() : '-' + token.lexeme();
    }

    @Override
    public String visitAddExpr(AddExpr expression) {
        return visitBinaryExpr(expression);
    }

    @Override
    public String visitSubExpr(SubExpr expression) {
        return visitBinaryExpr(expression);
    }

    @Override
    public String visitMulExpr(MulExpr expression) {
        return visitBinaryExpr(expression);
    }

    @Override
    public String visitDivExpr(DivExpr expression) {
        return visitBinaryExpr(expression);
    }

    @Override
    public String visitModExpr(ModExpr expression) {
        return visitBinaryExpr(expression);
    }

    @Override
    public String visitPowExpr(PowExpr expression) {
        StringBuilder builder = new StringBuilder();

        // NOTE: This is where right-associativity is handled for exponentiation
        if (expression.left().precedence().compareTo(expression.precedence()) <= 0) {
            builder.append(parenthesize(expression.left().accept(this)));
        } else {
            builder.append(expression.left().accept(this));
        }

        return builder.append(expression.separator())
                .append(parenthesizeIfNeeded(expression, expression.right(), Side.RIGHT))
                .toString();
    }

    private String visitBinaryExpr(BinaryExpr expression) {
        return parenthesizeIfNeeded(expression, expression.left(), Side.LEFT) +
                ' ' + expression.separator() + ' ' +
                parenthesizeIfNeeded(expression, expression.right(), Side.RIGHT);
    }

    private boolean innerHasLowerPrecedence(Expr outer, Expr inner) {
        return inner.precedence().compareTo(outer.precedence()) < 0;
    }

    private String parenthesize(String expression) {
        return '(' + expression + ')';
    }

    private String parenthesizeIfNeeded(Expr outer, Expr inner, Side side) {
        String innerExpansion = inner.accept(this);

        // FIXME: Ad-hoc solution! We check only to see if the left most char in the rhs expression is '-'.
        if (innerHasLowerPrecedence(outer, inner) || (side == Side.RIGHT && innerExpansion.startsWith("-"))) {
            return parenthesize(innerExpansion);
        }

        return innerExpansion;
    }
}
